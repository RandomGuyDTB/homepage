<!DOCTYPE html>
<HTML LANG="en">
<HEAD>
<LINK HREF="http://www.trinity.moe/knowledge/cat" REL="canonical" />
<LINK HREF="https://raw.githubusercontent.com/devenblake/homepage/main/favicon.ico" REL="shortcut icon" TYPE="image/x-icon" />
<LINK HREF="/css/blank.css" ID="highlight" REL="stylesheet" />
<LINK HREF="/css/blank.css" ID="styling" REL="stylesheet" />
<META CHARSET="UTF-8" />
<META CONTENT="interest-cohort=()" HTTP-EQUIV="Permissions-Policy" /> <!-- FUCK GOOGLE -->
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1" />
<TITLE>cat(1)</TITLE>
</HEAD>
<BODY>
<P><A HREF="/">~ Return to the rest of the site</A></P>

<SCRIPT SRC="/cookies.js" TYPE="application/javascript"></SCRIPT>
<SCRIPT SRC="/sheets.js"  TYPE="application/javascript"></SCRIPT>
<SCRIPT TYPE="application/javascript">window.onload = window.initializesheets;</SCRIPT>
<SCRIPT TYPE="application/javascript">
/* Special thanks to wiresToGround and adamz01h for their help getting this
 * JavaScript to work. */
window.is_highlightjs_here = false;
window.is_highlighted_languages = [];
window.to_be_highlighted = [];
window.is_highlight_stylesheet_here = false;
window.load_highlighting = function(language){
	var element;
	var script;
	document.getElementById(language + "_toggle").remove();
	if(!window.is_highlight_stylesheet_here){
		document.getElementById("highlight").setAttribute("href", "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/default.min.css");
		window.is_highlight_stylesheet_here = true;
	}
	if(!window.is_highlightjs_here){
		script = document.createElement('script');
		script.async = false;
		script.src = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js";
		document.body.appendChild(script);
		window.is_highlightjs_here = true;
	}
	if(window.is_highlighted_languages.indexOf(language) == -1){
		window.to_be_highlighted.push(language);

		script = document.createElement('script');
		script.async = false;
		script.src = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/languages/" + language + ".min.js";
		script.onload = function(){
			var language = window.to_be_highlighted.shift()
			var elements = document.getElementsByClassName("language-" + language);
			for(var i = 0; i < elements.length; ++i)
				try{
					hljs.highlightElement(elements[i]);
				}catch(err){
					console.log(err.message);
				}

			window.is_highlighted_languages.push(language);
		}
		document.body.appendChild(script);
	}
}
</SCRIPT>

<H1>POSIX cat(1) WIP ARTICLE</H1>
<H3>updated 2021-06-20</H3>
<HR ALIGN="left" SIZE="1" WIDTH="25%" />
<P>
<CODE>cat</CODE> on a POSIX or otherwise UNIX-like system is a program that exists to concatenate files; to “join” one file at its end to another at its start, and output that resulting file to standard output.
</P>
<P>
<CODE>cat</CODE> was introduced in UNIX v1 to supercede the program pr which printed the contents of a single file to the screen (McIlroy); its first-edition manual page described cat as “about the easiest way to print a file” (“cat(1)”).
<CODE>cat</CODE>’s modern, typical use is more or less the same; it’s often introduced to UNIX beginners as a method to print the contents of a file to the screen, which is why many implementations of <CODE>cat</CODE> include options that are technically redundant - see the often-included <CODE>cat</CODE> <CODE>-e</CODE>, <CODE>-t</CODE>, and <CODE>-v</CODE> that replace the ends of lines, tabs, and invisible characters respectively with printing portrayals (“cat(1p)”).
</P>
<P>
The POSIX standard as of 2003 requires only the option <CODE>-u</CODE> to be implemented, which prevents <CODE>cat</CODE> from buffering its output - on some systems, <CODE>cat</CODE> buffers its output in 512-byte blocks (McIlroy), similarly to <CODE>dd</CODE>’s default as defined by POSIX (“dd(1p)”), though most currently popular <CODE>cat</CODE> implementations do this by default and ignore the <CODE>-u</CODE> flag altogether (busybox, GNU coreutils).
POSIX doesn’t mandate buffering by default - specifically, <CODE>-u</CODE> <I>has</I> to guarantee that the output is unbuffered, but <CODE>cat</CODE> doesn't have to buffer it in the first place and can ignore <CODE>-u</CODE> in that case.
</P>
<P>
This is a POSIX-compliant implementation of UNIX <CODE>cat</CODE> with no additional features nor buffered output in C:
</P>
<INPUT ID="c_toggle" ONCLICK="window.load_highlighting('c');" TYPE="button" VALUE="Press this button to enable syntax highlighting within this code." />
<PRE><CODE CLASS="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define STDIN_NAME "&lt;stdin&gt;"
#define STDOUT_NAME "&lt;stdout&gt;"

/* these two errors will exit out of the program with an unsuccessful status,
 * and print a diagnostic message to standard error */
void
file_access_error(char *argv0, char *file_name){
	fprintf(stderr, "%s: %s: cannot open file\n", argv0, file_name);
	exit(1);
}

void
file_write_error(char *argv0, char *file_name){
	fprintf(stderr, "%s: %s: error writing to file\n", argv0, file_name);
	exit(1);
}

/* print input to output, returns 0 if successful and 1 if unsuccessful */
int
file_copy(FILE *input, FILE *output){
	char c;
	while((c = getc(input)) != EOF)
		if(putc(c, output) == EOF)
			return 1;
	return 0;
}

int
main(int argc, char *argv[]){
	/* the name of the file being printed (for diagnostics) */
	char *file_name;

	/* allocate this ahead of time */
	char *stdin_file_name = STDIN_NAME;

	/* the file pointer of the file being printed */
	FILE *input;

	/* this will always be stdout */
	FILE *output = stdout;

	int i;

	/* whether or not options are being parsed */
	int parsing_opts = 1;

	/* usage with 0 arguments - print standard input to standard output */
	if(argc == 1 &amp;&amp; file_copy(stdin, stdout))
		file_write_error(argv[0], STDOUT_NAME);
	else if(argc == 1)
		return 0;

	for(i = 1; i &lt; argc; ++i){
		/* parsing options */

		/* after `--`, interpret `--`, `-`, and `-u` as literal
		 * filenames */
		if(parsing_opts &amp;&amp; !strcmp(argv[i], "--")){
			parsing_opts = 0;
			continue;
		/* ignore `-u` if still parsing options */
		}else if(parsing_opts &amp;&amp; !strcmp(argv[i], "-u"))
			continue;

		/* take `-` to mean standard input if still parsing options */
		else if(parsing_opts &amp;&amp; !strcmp(argv[i], "-")){
			file_name = stdin_file_name;
			input = stdin;

		/* non-option; open the file and make sure file_name points to
		 * the right string */
		}else{
			file_name = argv[i];
			input = fopen(file_name, "r");
			if(input == NULL)
				file_access_error(argv[0], file_name);
		}

		/* print input to output */
		if(file_copy(input, output))
			file_write_error(argv[0], STDOUT_NAME);
	}

	/* exit successfully */
	return 0;
}
</CODE></PRE>

<P>It’s worth noting that this concept of cat as a utility that sequentially prints given files to standard output means <CODE>cat</CODE> can be replaced by a simple shell script that does the same using <CODE>dd</CODE> and <CODE>printf</CODE>; <CODE>cat</CODE> as defined by POSIX is actually totally redundant to other POSIX utilities. Here’s the shell script:</P>
<INPUT ID="shell_toggle" ONCLICK="window.load_highlighting('shell');" TYPE="button" VALUE="Press this button to enable syntax highlighting within this code." />
<PRE><CODE CLASS="language-shell">
#!/bin/sh

# some older systems will use the former POSIX_ME_HARDER rather than
# POSIXLY_CORRECT to request strict POSIX coherence
[ -n "$POSIX_ME_HARDER" ] &amp; [ -z "$POSIXLY_CORRECT" ] \
	&amp;&amp; POSIXLY_CORRECT=1
	|| true

# for usage()
argv0="$0"

# dd_ is used so that dd can easily be re-defined to the unbuffered variant -
# dd bs=1
dd_() { dd "$@"; }

# if the system wants strict POSIX coherence, don't permit usage of `cat -h`
# because it's not defined by POSIX
usage() {
	[ -z "$POSIXLY_CORRECT" ] \
		&amp;&amp; printf "Usage: %s [-hu] [file...]\n" "$argv0" \
		|| printf "Usage: %s [-u] [file...]\n" "$argv0"
	exit 1
}

# usage with 0 arguments - print standard input to standard output
if [ -z "$1" ]; then
	dd_ 2&gt;/dev/null
	exit $?
fi

while [ -n "$1" ]; do
	# parsing options

	# after `--`, interpret `--`, `-`, and `-u` as literal filenames
	[ "$1" = "--" ] &amp;&amp; [ -z "$DONT_PARSE_ARGS" ] \
		&amp;&amp; DONT_PARSE_ARGS=1 &amp;&amp; shift 1 &amp;&amp; continue \
		|| true

	# if `-u` specified and still parsing options, enable unbuffered output
	# this dd is probably super slow. TODO?: find better way
	[ "$1" = "-u" ] &amp;&amp; [ -z "$DONT_PARSE_ARGS" ] \
		&amp;&amp; dd_() { dd bs=1 "$@"; } &amp;&amp; shift 1 &amp;&amp; continue \
		|| true

	# the `-h` flag isn't specified within POSIX, so ignore it if the
	# environment is strictly conforming to POSIX
	[ "$1" = "-h" ] &amp;&amp; [ -z "$DONT_PARSE_ARGS" ] \
			&amp;&amp; [ -z "$POSIXLY_CORRECT" ] \
		&amp;&amp; usage \
		|| true

	# take `-` to mean standard input if still parsing options
	if [ "$1" = "-" ] &amp;&amp; [ -z "$DONT_PARSE_ARGS" ]; then
		dd_ &lt;/dev/stdin 2&gt;/dev/null || exit $?
		shift 1
		continue
	fi

	# print input to output
	dd_ &lt;"$1" 2&gt;/dev/null || exit $?

	shift 1
done

# exit successfully
exit 0
</CODE></PRE>

<P><CODE>cat</CODE> still has a purpose though. This shell script is relatively slow for short files and very slow for very large files (though dd itself should probably be used to copy large files from one medium to another anyway). This is provided for educational purposes (though I personally use this shell script in my system PATH; the C implementation provided compiles to a much larger binary using gcc 11.1.0, so this saves a couple kilobytes).</P>

<H2>Cited media and further reading</H2><UL>
<LI>Articles<UL>
	<LI><A HREF="https://www.cs.dartmouth.edu/~doug/reader.pdf">McIlroy, M. Douglas - “A Research Unix Reader”</A></LI>
	<LI><A HREF="https://en.wikipedia.org/wiki/POSIX#512-_vs_1024-byte_blocks">Wikipedia - “POSIX § 512- vs 1024-byte blocks”</A><UL>
		As of 2021-06-19 the publicly editable section reads: <I>POSIX mandates 512-byte default block sizes for the df and du utilities, reflecting the typical size of blocks on disks. When Richard Stallman and the GNU team were implementing POSIX for the GNU operating system, they objected to this on the grounds that most people think in terms of 1024 byte (or 1 KiB) blocks. The environment variable POSIX_ME_HARDER was introduced to allow the user to force the standards-compliant behaviour. The variable name was later changed to POSIXLY_CORRECT. This variable is now also used for a number of other behaviour quirks.</I>
		</UL></LI>
</UL></LI>
<LI>Popular cat implementations<UL>
	<LI><A HREF="https://www.busybox.net/">busybox</A>/<A HREF="https://git.busybox.net/busybox/">busybox</A> - <A HREF="https://git.busybox.net/busybox/tree/coreutils/cat.c">coreutils/cat.c</A></LI>
	<LI><A HREF="https://www.gnu.org/">GNU</A>/<A HREF="https://www.gnu.org/software/coreutils/">coreutils</A> - <A HREF="https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/cat.c">src/cat.c</A></LI>
</UL></LI>
<LI>Manual pages<UL>
	<LI><A HREF="http://man.cat-v.org/unix-1st/1/cat">cat(1)</A> (UNIX v1)</LI>
	<LI><A HREF="https://www.unix.com/man-page/posix/1posix/cat/">cat(1p)</A> (The Open Group, 2003)</LI>
	<LI><A HREF="https://www.unix.com/man-page/posix/1posix/dd/">dd(1p)</A> (The Open Group, 2003)</LI>
	<LI><A HREF="https://www.unix.com/man-page/POSIX/1posix/printf/">printf(1p)</A> (The Open Group, 2003)</LI>
</UL></LI>
</UL>
</BODY>
</HTML>
